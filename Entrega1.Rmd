---
title: "Entrega1"
author: "Pol Renau Miguel Angel Merino"
date: \today
output:
  word_document:
    toc: yes
    toc_depth: '4'
  html_document:
    toc: no
    toc_depth: '4'
  pdf_document:
    latex_engine: pdflatex
    number_sections: yes
    toc_depth: 4
    toc: yes
geometry: left=1.9cm,right=1.9cm,top=1.25cm,bottom=1.52cm
fontsize: 12pt
subtitle: 'Loading data and Sample selection'
editor_options:
  chunk_output_type: console
---



# Carregar les dades

Les dades es diuen adult.data i es troben en el directori actual.


```{r}

df<-read.table("adult.data",header=F, sep=",",fill=FALSE,              strip.white=TRUE,na.string="?")
dim(df)
names(df)

names(df)<-c("age", "type.employer", "fnlwgt", "education", "education.num","marital", "occupation",
             "relationship", "race","sex", "capital.gain", "capital.loss",
             "hr.per.week", "country", "y.bin")
summary(df)

```

## Selecció de la mostra

Inicialitzem un generador aleatori, amb una llavor que es igual a la data de neixament d'un dels integrants del grup, i agafem 5000 observacions de les dades totals

```{r}
set.seed(14121997)
sam<-sort(sample(1:nrow(df),5000))


str(df)

# Select sample
df<-df[sam,]

```

### Guardar la mostra

Guardarem la mostra com a mostra.RData, en el directori actua, aquest pas el podriem evitar, no obstant el fem perquè creiem que es important saber guardar les dades.

```{r}
save(list="df",file="mostra.RData")
```


# Fitxa de dades del cens

## Descripció

*variables d'entrada:*

  1.  age: continuous.
  2.  workclass: Private, Self-emp-not-inc, Self-emp-inc, Federal-gov, Local-gov, State-gov, Without-pay, Never-worked.
  3.  fnlwgt: continuous.
  4.  education: Bachelors, Some-college, 11th, HS-grad, Prof-school, Assoc-acdm, Assoc-voc, 9th, 7th-8th, 12th, Masters, 1st-4th, 10th, Doctorate, 5th-6th, Preschool.
  5.  education-num: continuous.
  6.  marital.status: Married-civ-spouse, Divorced, Never-married, Separated, Widowed, Married-spouse-absent, Married-AF-spouse.
  7.  occupation: Tech-support, Craft-repair, Other-service, Sales, Exec-managerial, Prof-specialty, Handlers-cleaners, Machine-op-inspct, Adm-clerical, Farming-fishing, Transport-moving, Priv-house-serv, Protective-serv, Armed-Forces.
  7.  relationship: Wife, Own-child, Husband, Not-in-family, Other-relative, Unmarried.
  8.  race: White, Asian-Pac-Islander, Amer-Indian-Eskimo, Other, Black.
  9.  sex: Female, Male.
  10.  capital.gain: continuous.
  11.  capital.loss: continuous.
  12.  hours.per.week: continuous. Numeric target.
  13.  native.country: United-States, Cambodia, England, Puerto-Rico, Canada, Germany, Outlying-US(Guam-USVI-etc), India, Japan, Greece, South, China, Cuba, Iran, Honduras, Philippines, Italy, Poland, Jamaica, Vietnam, Mexico, Portugal, Ireland, France, Dominican-Republic, Laos, Ecuador, Taiwan, Haiti, Columbia, Hungary, Guatemala, Nicaragua, Scotland, Thailand, Yugoslavia, El-Salvador, Trinadad&Tobago, Peru, Hong, Holand-Netherlands.
  15.  y.bin: Making more than $50K per year. Binary target.


## Carrega de paquets

Carregarem tots els paquets necessaris per utilitzar al llarg de la pràctica.

```{r}
options(contrasts=c("contr.treatment","contr.treatment"))

requiredPackages <- c("effects","FactoMineR","car", "factoextra","ggplot2","dplyr","ggmap","ggthemes","knitr")
missingPackages <- requiredPackages[!(requiredPackages %in% installed.packages()[,"Package"])]
if(length(missingPackages)) install.packages(missingPackages)

lapply(requiredPackages, require, character.only = TRUE)

```

## Carregar mostra

Carreguem el model previament creat.

```{r}
# Clear objects
rm(list=ls())
# Clear plots
if(!is.null(dev.list())) dev.off()

# Command or Windows-like method
load("mostra.RData")
summary(df)
```


# Algunes funcions útils
 Definim totes les funcions que ens podràn ser utils al llarg de la pràctica.

```{r}
calcQ <- function(x) {
  s.x <- summary(x)
  iqr<-s.x[5]-s.x[2]
  list(souti=s.x[2]-3*iqr, mouti=s.x[2]-1.5*iqr, min=s.x[1], q1=s.x[2], q2=s.x[3],
       q3=s.x[5], max=s.x[6], mouts=s.x[5]+1.5*iqr, souts=s.x[5]+3*iqr ) }

countNA <- function(x) {
  mis_x <- NULL
  for (j in 1:ncol(x)) {mis_x[j] <- sum(is.na(x[,j])) }
  mis_x <- as.data.frame(mis_x)
  rownames(mis_x) <- names(x)
  mis_i <- rep(0,nrow(x))
  for (j in 1:ncol(x)) {mis_i <- mis_i + as.numeric(is.na(x[,j])) }
  list(mis_col=mis_x,mis_ind=mis_i) }
```


# Preparació de les dades

Preparació de les dades, separem entre aquelles variables que tenen un valor numéric i aquelles que són descriptives

```{r}
names(df)
vars_con<-names(df)[c(1,3,5,11:13)];vars_con
vars_dis<-names(df)[c(2,4,6:10,14:15)];vars_dis

summary(df[,vars_con]) # Example of descriptive for numeric variables

summary(df[,vars_dis])


```


## Preparació dels factors

En aquest apartat realitzarem la reagrupació d'aquells factors en classes més generals, això només ho farem per aquelles variables que hem cregut necesaries, de reagrupar en altres clases.

### type.employer



*Desició conceptual:*

  1. Civil => Federal, local and state gov
  2. Private
  3. SelfEm => Treballadors autonoms amb ingresos.
  4. Other => Self-emp-not-inc, Never-worked, Without-pay

```{r}
par(mfrow=c(1,2))

levels(df$type.employer)


barplot(table(df$type.employer),main="Original",col=rainbow(12))
table(df$type.employer)

# Conceptual decission : federal, local and state gov are grouped together - Private alone , Self-emp and the rest together



tapply(df$hr.per.week,df$type.employer,mean)
df$f.type<-1
ll<-which(df$type.employer == "Private");length(ll)
df$f.type[ll]<-2
ll<-which(df$type.employer == "Self-emp-inc");length(ll)
df$f.type[ll]<-3
ll<-which(df$type.employer %in% c("Self-emp-not-inc","Never-worked","Without-pay"));length(ll)
df$f.type[ll]<-4


df$f.type<-factor(df$f.type,levels=1:4,labels=paste0("f.typ-",c("Civil","Private","SelfEm","Other")))

summary(df$f.type)
summary(df$type.employer)

barplot(table(df$f.type),main="Reagrupat",col=rainbow(12))

```

### marital


*Desició conceptual:*

  1. Married => tots aquells que esan casats
  2. No-married=> Divorced i Separated
  3. Never-Married
  4. Widowed

```{r}
levels(df$marital)

barplot(table(df$marital),main="Original",col=rainbow(12))
table(df$marital)

tapply(df$hr.per.week,df$marital,mean)

df$f.marital<-1
ll<-which(df$marital %in% c ("Divorced","Separated")); length(ll)
df$f.marital[ll]<-2
ll<-which(df$marital == "Never-married"); length(ll)
df$f.marital[ll]<-3
ll<-which(df$marital == "Widowed"); length(ll)
df$f.marital[ll]<-4

df$f.marital<-factor(df$f.marital,levels=1:4,labels=paste0("f.marital-",c("Married","No- Married","Never-married","Widowed")))

summary(df$f.marital)

barplot(table(df$f.marital),main="Reagrupat",col=rainbow(12))

```

### education


*Desició conceptual:*

  1. Non-Graduatee => tots aquells que  no han superat res més que els estudis obligatoris, o bé que no ho han fet
  2. Some-college
  3. University-Or-More => Doctorate, Bachelors, HS-grad, Masters
  4. Assoc => Assoc-acdm, Assoc-voc
  5. Prof-school

```{r}
levels(df$education)

barplot(table(df$education))
table(df$education)


tapply(df$hr.per.week,df$education,mean)

df$f.education<-1
ll<-which(df$education == "Some-college")
df$f.education[ll]<-2
ll<-which(df$education %in% c("Doctorate","Bachelors","HS-grad","Masters"))
df$f.education[ll]<-3
ll<-which(df$education %in% c("Assoc-acdm","Assoc-voc"))
df$f.education[ll]<-4
ll<-which(df$education == "Prof-school")
df$f.education[ll]<-5

# Define f.type as a factor and use 'nice' level names

df$f.education<-factor(df$f.education,levels=1:5,labels=paste0("f.education-",c("Non-Graduate","Some-college","University-Or-More","Assoc","Proof-school")))

summary(df$f.education)

barplot(table(df$f.education))
```





## Discretització de variables numèriques

En aquest apartat reagruparem totes aquelles variables númeriques en categories més generals, segons el nostre criteri pròpi.

### Age
Agruparem el terme edat en els valors de tall que ens donen els quartils de la mostra.

*Desició conceptual:*

  1. [17-29]
  2. [30,39]
  3. [40,49]
  4. [50,90]


```{r}
summary(df$age)

# Try 4 categories first
quantile(df$age)

df$f.age<-factor(cut(df$age,quantile(df$age),include.lowest = T))
summary(df$f.age)

# Reasonable according to target?
tapply(df$age,df$f.age,median) # OK

# Alternative breaks defined at 30,40,50
df$f.age<-factor(cut(df$age,c(17,29,39,49,90),include.lowest = T))
summary(df$f.age)
levels(df$f.age)<-paste0("f.age-",levels(df$f.age))

barplot(table(df$age),main="Original",col=rainbow(12))

barplot(table(df$f.age),main="Discret",col=rainbow(12))

```

### capital.gain & capital.loss

Hem cregut que aquestes variables tenen una relació gran que sería el benefici, es a dir capital.gain - capital.loss.

*Desició conceptual:*

  1. Neutre
  2. Positiu
  3. Negatiu


```{r}
df$f.benefici<-1 #Neutre
ll<-which((df$capital.gain - df$capital.loss) > 0)
df$f.benefici[ll]<-2 #positiu
ll<-which((df$capital.gain-df$capital.loss) < 0)
df$f.benefici[ll]<-3


df$f.benefici<-factor(df$f.benefici,levels=1:3,labels=paste0("f.benefici-",c("Neutre","Positiu","Negatiu")))

summary(df$f.benefici)

par(mfrow=c(1,1))
barplot(table(df$f.benefici))

par(mfrow=c(1,2))
```


# Qualitat de les dades

En aquest apartat, per cada variable contarem el nombre d'errors, missings i outliers. Per definir els outliers i errors, en cada categoria s'establiran valors limits en els que considerarem que a apartir d'allà ja són valors que poden comprometrer la qualitat de les dades. I per cada individu calcularem el nombre total d'errors + missings + outliers i s'afegira com una variable extra del dataframe.

```{r}
iout<-rep(0,nrow(df))
jout<-rep(0,length(vars_con))

ierr<-rep(0,nrow(df))
jerr<-rep(0,ncol(df))

imiss<-rep(0,nrow(df))
jmiss<-rep(0,ncol(df))

summary(df[,vars_con])
dfaux<-df
```

Hem creat un dataframe auxiliar que serà una copia del dataframe original, per poder fer en tot moment la compartiva del que són les dades reals i les dades que anem tractant.


## age
Per a la variable "age", establim que tota edat que sigui 0 o bé sigui negatia serà considerada com a error.
```{r}

#Calcul missing data
missingData<-which(is.na(dfaux$age)); length(missingData) #no missing data

#Calcul errors (que assignem com NA per a la inputation)
sel<-which(df$age <= 0); length(sel) # errors
if(length(sel)>0){
  dfaux[sel,"age"]<-NA
}
# No tenim missin data ni errors d'edat negativa, comprobem els outliers severs.

#Calcul several outliers (i assignar na)
outers <- calcQ(dfaux$age)

outlier<-which(dfaux$age > outers$souts);length(outlier)
dfaux[outlier ,"age"]<-NA

outlier<-which(dfaux$age < outers$souti);length(outlier)
dfaux[outlier ,"age"]<-NA

# 0 outliers severs, es adir que per la variable age no tenim ni errors ni miss

outlier<-which(dfaux$age > outers$mouts);length(outlier)
# tenim 18 outliers superiors, segons la definició de outlier, no obstant considerem que en la diversitat de les dades es normal que hi hagi poca gent d'una edat avançada. Per tant no els considerarem com a outliers.

outlier<-which(dfaux$age < outers$mouti);length(outlier)
#tenim 0 outliers inferiors.

par(mfrow=c(1,1))
boxplot(df$age)
# A continuació veiem per on tallarien els outliers la mostra d'entrada.
abline(h= outers$mouts,col="red",lty=2)

```

Per aquesta variable, hem decidit que no hi hauran outliers, ja que els outliers que ens dona la teoria de quartils, creiem que no representen la diversitat d'aquest cens. Per tant mostrem un boxplot on es veu per on hauriem de tallar segons els valors teorics, no obstant per desició pròpia decidim no fer-ho.

## workclass

Per aquesta variable, hem establert que com a errors tractarem com a errors a tots aquells valors que no formin part de les categories d'entrada definides al inici.
```{r}
missingData<-which(is.na(dfaux$type.employer)); length(missingData)
imiss[missingData]<- imiss[missingData] +1
jmiss[2] <- jmiss[2]+ length(missingData)

#Tractarem com a error tot allo que no pertanyi al rang de valors que contemplem
sel<-which(df$type.employer != 'Private' & df$type.employer != 'Self-emp-not-inc' &
             df$type.employer != 'Self-emp-inc' & df$type.employer != 'Federal-gov' &
             df$type.employer != 'Local-gov' & df$type.employer != 'State-gov' &
             df$type.employer != 'Without-pay' & df$type.employer != 'Never-worked'); length(sel) # errors

if(length(sel)>0){
  dfaux[sel,"type.employer"]<-NA
}

#Tenim 0 errors
```

Com podem observar no hi han ni errors, no obstant si que tenim algun NA.
